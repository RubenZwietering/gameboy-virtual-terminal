include "macros.inc"

export _print_byte
export print_byte
export _print_bitsh
export print_bitsh
export _print_bits
export print_bits
export _print_string
export print_string
export _vprintf
export vprintf
export _printf

def FORMATB_BEHAVIOUR_LEFT_JUSTIFIED 			equ 0
def FORMATB_BEHAVIOUR_SIGN_PREPENDED 			equ 1
def FORMATB_BEHAVIOUR_SPACE 					equ 2
def FORMATB_BEHAVIOUR_ALTERNATIVE_FORM 			equ 3
def FORMATB_BEHAVIOUR_LEADING_ZEROS 			equ 4
def FORMATB_HAS_MINIMUM_FIELD_WIDTH_SPECIFIER 	equ 5
def FORMATB_HAS_PRECISION_SPECIFIER 			equ 6

section "print functions", ROMX
; _print_byte
; 
; description:
; print a byte
; 
; c function signiature:
; int print_byte(unsigned char);
;
; input:
; - `a` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_byte:
	; fallthrough

; print_byte
;
; input:
; - `a` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_byte:
	ld c, $0f
	ld h, HIGH(hex_map)
	ld b, a

	and c
	ld l, a
	push hl

	ld a, b
	swap a
	and c
	ld l, a
	ld a, [hl]

	call putchar

	pop hl
	ld a, [hl]

	call putchar

	ld bc, 2
	ret
; print_byte
; _print_byte


; print_non_zero_nibbles
; 
; description:
; print byte without leading zero nibbles
;
; input:
; - `a` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_non_zero_nibbles:
	ld c, $0f
	ld h, HIGH(hex_map)
	ld b, a

	and c
	ld l, a
	push hl

	ld a, b
	swap a
	and c
	ld l, a
	ld a, [hl]

	call nz, putchar

	pop hl
	ld a, [hl]

	call putchar

	; TODO: return correct number of characters written
	ld bc, 1
	ret
; print_non_zero_nibbles


; _print_bitsh
; 
; description:
; print the bits of an 8 bit value with precision
; 
; c function signiature:
; int print_bitsh(unsigned char precision, unsigned char bits);
;
; input:
; - `a` : precision
; - `e` : bits
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_bitsh:
	; fallthrough

; print_bitsh
;
; input:
; - `a` : precision
; - `e` : bits
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_bitsh:
	cp 9
	jr nc, .extra_padding

	ld d, a
	ld a, 8
	sub d ; 8 - a
	jr z, .no_discard_zeros
		inc a
		.discard_leading_zeros_loop
			dec a
			jr z, .break_discard_leading_zeros_loop
			sla e
		jr nc, .discard_leading_zeros_loop
		rr e
		
		.break_discard_leading_zeros_loop
		
		add d
		ret z
		ld d, a
	.no_discard_zeros

	.print_bit_loop
		xor a
		sla e
		adc "0"

		push de
		call putchar
		pop de

		dec d
	jr nz, .print_bit_loop
	ret

	.extra_padding
		push de

		sub 8
		ld l, a
		ld h, "0" ; TODO: sign extend?

		.extra_padding_loop
			ld a, h
			push hl
			call putchar
			pop hl
			dec l
		jr nz, .extra_padding_loop

		pop de
		ld d, 8
		jr .print_bit_loop
; print_bitsh
; _print_bitsh


; _print_bits
; 
; description:
; print the bits of a 16 bit value with precision
; 
; c function signiature:
; int print_bits(unsigned char precision, unsigned int bits);
;
; input:
; - `a` : precision
; - `de` : bits
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_bits:
	; fallthrough

; print_bits
;
; input:
; - `a`  : precision TODO: 16 bit
; - `de` : bits
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_bits:
	cp 17
	jr c, .no_extra_padding
		push de
		sub 16
		ld l, a
		ld h, "0" ; TODO: sign extend?

		.extra_padding_loop
			push hl
			ld a, h
			call putchar
			pop hl
			dec l
		jr nz, .extra_padding_loop

		ld a, 16
		pop de
	.no_extra_padding

	ld l, d
	ld d, a
	push de
	ld e, l
	
	sub 8 ; jump if a > 8
	jr nc, .bigger_than_8
		xor a ; ld a, 0
	.bigger_than_8

	call print_bitsh
	pop de

	ld a, d
	cp 9 ; jump if a <= 8
	jr c, .smaller_than_9
		ld a, 8
	.smaller_than_9

	jp print_bitsh
; print_bits
; _print_bits


; _print_hex
; 
; description:
; print a hexadecimal integer,
; leading zero nibbles are ignored
;
; c function signiature:
; int print_hex(unsigned int);
;
; input:
; - `de` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_hex:
	; fallthrough

; print_hex
;
; input:
; - `de` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_hex:
	ld a, d
	or a
	jr z, .ignore_upper_bits
		push de
		call print_non_zero_nibbles
		pop de

		ld a, e
		call print_byte

		; TODO: return correct number of characters written
		ld bc, 3 ; or 4
		ret
	.ignore_upper_bits

	ld a, e
	call print_non_zero_nibbles

	; TODO: return correct number of characters written
	ld bc, 1 ; or 2
	ret
; print_hex
; _print_hex


; _print_hexl
; 
; description:
; print a hexadecimal long integer,
; leading zero nibbles are ignored
;
; c function signiature:
; int print_hexl(unsigned long);
;
; input:
; - `debc` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_hexl:
	; fallthrough

; print_hexl
;
; input:
; - `debc` : value
;
; returns:
; - `bc` : number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_hexl:
	ld a, d
	or e
	jr z, .ignore_upper_bits
		push bc
		call print_hex
		pop de

		call print_hex

		; TODO: return correct number of characters written
		ld bc, 5 ; to 8
		ret
	.ignore_upper_bits

	ld d, b
	ld e, c
	jp print_hex
; print_hexl
; _print_hexl


; _print_string
;
; c function signiature:
; int print_string(const char*);
;
; input:
; - `de` : string ptr
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_print_string:
	LD_R16_R16 hl, de
	; fallthrough

; print_string
;
; input:
; - `hl` : string ptr
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
print_string:
	ld a, [hli]
	or a
	ret z

	push hl
	call putchar
	pop hl
	jr print_string
; print_string
; _print_string


; _vprintf
;
; c function signiature:
; int vprintf(const char*, va_list);
;
; input:
; - `de` : fmt string ptr
; - `bc` : variable arguments list ptr
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_vprintf:
	LD_R16_R16 hl, de

; vprintf
;
; input:
; - `hl` : fmt string ptr
; - `bc` : variable arguments list ptr
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
vprintf:
	ld a, [hli]

	or a ; cp "\0"
	ret z
	
	cp "%"
	jr z, .fmt_specifier

	push hl
	push bc
	call putchar
	pop bc
	pop hl
	jr vprintf
	
	.fmt_specifier
		ld a, [hli]

		or a ; cp "\0"
		ret z

		; introductory % character
		; behaviour flags
		; minimum field width specfier
		; . precision specifier
		; length modifier
		; conversion format specifier

		cp "-"
		jp z, .flag_left_justified
		cp "+"
		jp z, .flag_sign_prepended
		cp " "
		jp z, .flag_space
		cp "#"
		jp z, .flag_alternative_form

		sub "0"
		jp z, .flag_leading_zeros
		cp 10
		jr c, .minimum_field_width_specifier 
		add "0"

		cp "."
		jp z, .precision_specifier
		.exit_precision_specifier

		; length modifiers: hh, h, l, ll, j, z, t, L

		cp "c"
		jp z, .conversion_c
		cp "s"
		jp z, .conversion_s
		cp "d"
		jp z, .conversion_i
		cp "i"
		jp z, .conversion_i
		cp "o"
		jp z, .conversion_o
		cp "x"
		jp z, .conversion_x_lower
		cp "X"
		jp z, .conversion_x_upper
		cp "u"
		jp z, .conversion_u
		cp "b"
		jp z, .conversion_b
		; f/F, e/E, a/A, g/G, n
		cp "p"
		jp z, .conversion_p

		push hl
		push bc
		call putchar
		pop bc
		pop hl
		jp vprintf

	.flag_left_justified
		set FORMATB_BEHAVIOUR_LEFT_JUSTIFIED, d
		jp .fmt_loop
	.flag_sign_prepended
		set FORMATB_BEHAVIOUR_SIGN_PREPENDED, d
		jp .fmt_loop
	.flag_space
		set FORMATB_BEHAVIOUR_SPACE, d
		jp .fmt_loop
	.flag_alternative_form
		set FORMATB_BEHAVIOUR_ALTERNATIVE_FORM, d
		jp .fmt_loop
	.flag_leading_zeros
		set FORMATB_BEHAVIOUR_LEADING_ZEROS, d
		jp .fmt_loop

	.minimum_field_width_specifier 
		; minimum field with specifier not supported yet
		set FORMATB_HAS_MINIMUM_FIELD_WIDTH_SPECIFIER, d
		jp .fmt_loop

	.precision_specifier
		bit FORMATB_HAS_PRECISION_SPECIFIER, d
		jr nz, .exit_fmt
		set FORMATB_HAS_PRECISION_SPECIFIER, d
		ld e, 0 ; precision
		
		ld a, [hli]

		or a ; cp "\0"
		ret z

		cp "*"
		jr z, .precision_specifier_asterisk
		sub "0"
		cp 10
		jr c, .precision_specifier_digit
		add "0"

		jp .exit_precision_specifier

	.precision_specifier_asterisk
		ld a, [bc]
		ld e, a
		inc bc
		inc bc

		ld a, [hli]

		or a ; cp "\0"
		ret z

		jp .exit_precision_specifier

	.precision_specifier_digit
		push bc

		; e = e * 10 + a
		ld b, a
		ld a, e
		ld c, a
		add a
		add a
		add c
		add a
		add b
		ld e, a

		pop bc

		ld a, [hli]

		or a ; cp "\0"
		ret z
		
		sub "0"
		cp 10
		jr c, .precision_specifier_digit
		add "0"
		jp .exit_precision_specifier

	.conversion_c
		push hl
		
		ld a, [bc]
		inc bc
		inc bc
		
		push bc
		call putchar
		pop bc

		pop hl
		jp vprintf

	.conversion_s
		push hl

		ld a, [bc]
		ld l, a
		inc bc
		ld a, [bc]
		ld h, a
		inc bc
		
		push bc
		call print_string
		pop bc

		pop hl
		jp vprintf

	.conversion_i
		push hl

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc

		push bc

		cp $80
		jr c, .positive
			push de
			ld a, "-"
			call putchar
			pop de

			TWOS_COMPLEMENT_R16 de
		.positive

		call _bcd

		call print_hexl

		pop bc

		pop hl
		jp vprintf 
	
	.conversion_o
		jp vprintf
	
	.conversion_x_lower
		push hl

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc

		push bc

		call print_hex

		pop bc

		pop hl
		jp vprintf
	
	.conversion_x_upper
		push hl

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc

		push bc

		call print_hex

		pop bc

		pop hl
		jp vprintf
		
	.conversion_u
		push hl

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc
		
		push bc

		call _bcd

		call print_hexl

		pop bc

		pop hl
		jp vprintf

	.conversion_b
		push hl

		; TODO: nice bit manipulation for this instead?
		bit FORMATB_HAS_PRECISION_SPECIFIER, d
		jr z, .no_precision_specifier
			ld l, e
			jr .has_precision_specifier
		.no_precision_specifier
			ld l, 1
		.has_precision_specifier

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc

		push bc

		ld a, l

		call print_bits

		pop bc

		pop hl
		jp vprintf

	.conversion_p
		push hl

		ld a, [bc]
		ld e, a
		inc bc
		ld a, [bc]
		ld d, a
		inc bc

		push bc
		push de

		ld a, d

		call print_byte

		pop de

		ld a, e
		
		call print_byte

		pop bc

		pop hl
		jp vprintf
; vprintf
; _vprintf


; _printf
;
; c function signiature:
; int printf(const char*, ...);
;
; input:
; - stack : fmt string ptr, variable arguments
;
; returns:
; - `bc` : TODO: number of characters written
;
; destroys `af`, `bc`, `de`, `hl`
_printf:
	ld	hl, sp+4 ; variable arguments list ptr
	LD_R16_R16 bc, hl
	
	ld	hl, sp+2 ; format string ptr ptr
	ld	e, [hl]
	inc	hl
	ld	d, [hl]
	jp	_vprintf
; _printf
