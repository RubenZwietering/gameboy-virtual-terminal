include "memory.inc"

export ld_hl_pc
export ld_de_pc
export memcpyh
export memcpy
export memseth
export memset
export memcplh
export memcpl
export vmemcpyh
export vmemcpy
export vmemseth
export vmemset
export vmemcplh
export vmemcpl

section "memory functions", ROMX
; ld_hl_pc
;
; load current pc in hl at runtime.
;
; returns:
; - `hl` : pc
;
; destroys `af`
ld_hl_pc:
	ld hl, sp+0
	
	; pop without changing sp
	ldi a, [hl]
	ld h, [hl]
	ld l, a
	
	ret
; ld_hl_pc


; ld_de_pc
;
; load current pc in hl at runtime.
;
; returns:
; - `de` : pc
;
; destroys `af`, `hl`
ld_de_pc:
	ld hl, sp+0
	
	; pop without changing sp
	ldi a, [hl]
	ld d, [hl]
	ld e, a
	
	ret
; ld_de_pc


; memcpyh
;
; 8 bit memcpy. if a size of 0 is passed, 256 bytes are copied instead
; 
; input
; - `hl` : destination
; - `de` : source
; - `c` : size
;
; destroys `af`, `de`, `c`, `hl`
memcpyh:
	ld a, [de]
	ld [hli], a
	inc de
	dec c
	jr nz, memcpyh
	ret
; memcpyh


; memcpy
;
; input
; - `hl` : destination
; - `de` : source
; - `bc` : size
;
; destroys `af`, `de`, `bc`, `hl`
memcpy:
	inc b
	inc c
	jr .skip

	.loop
		ld a, [de]
		ld [hli], a
		inc de
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; memcpy


; memseth
;
; 8 bit memset. if a size of 0 is passed, 256 bytes are set instead
;
; input
; - `a`  : value
; - `hl` : destination
; - `c` : size
;
; destroys `f`, `c`, `hl`
memseth:
	ld [hli], a
	dec c
	jr nz, memseth
	ret
; memseth


; memset
;
; input
; - `a`  : value
; - `hl` : destination
; - `bc` : size
;
; destroys `f`, `bc`, `hl`
memset:
	inc b
	inc c
	jr .skip

	.loop
		ld [hli], a
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; memset

; memcplh
;
; 8 bit memcpl. if a size of 0 is passed, 256 bytes are complemented instead
;
; input
; - `hl` : destination
; - `bc` : size
;
; destroys `af`, `c`, `hl`
memcplh:
	ld a, [hl]
	cpl
	ld [hli], a
	dec c
	jr nz, memcplh
	ret
; memcplh


; memcpl
;
; input
; - `hl` : destination
; - `bc` : size
;
; destroys `af`, `bc`, `hl`
memcpl:
	inc b
	inc c
	jr .skip

	.loop
		ld a, [hl]
		cpl
		ld [hli], a
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; memcpl


; vmemcpyh
;
; 8 bit vram memcpy. if a size of 0 is passed, 256 bytes are copied instead
;
; input
; - `hl` : destination
; - `de` : source
; - `c` : size
;
; destroys `af`, `de`, `c`, `hl`
vmemcpyh:
	WAIT_BLANK
	ld a, [de]
	ld [hli], a
	inc de
	dec c
	jr nz, vmemcpyh
	ret
; vmemcpyh


; vmemcpy
;
; input
; - `hl` : destination
; - `de` : source
; - `bc` : size
;
; destroys `af`, `de`, `bc`, `hl`
vmemcpy:
	inc b
	inc c
	jr .skip

	.loop
		WAIT_BLANK

		ld a, [de]
		ld [hli], a
		inc de
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; vmemcpy


; vmemseth
;
; 8 bit vram memset. if a size of 0 is passed, 256 bytes are set instead
;
; input
; - `a`  : value
; - `hl` : destination
; - `bc` : size
;
; destroys `f`, `bc`, `hl`
vmemseth:
	ld b, a
	.loop
		WAIT_BLANK

		ld a, b
		ld [hli], a
		dec c
		jr nz, .loop
	ret
; vmemseth


; vmemset
;
; input
; - `a`  : value
; - `hl` : destination
; - `bc` : size
;
; destroys `f`, `bc`, `e`, `hl`
vmemset:
	inc b
	inc c
	ld e, a
	jr .skip

	.loop
		WAIT_BLANK

		ld a, e
		ld [hli], a
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; vmemset


; vmemcplh
;
; 8 bit vram memset. if a size of 0 is passed, 256 bytes are complemented instead
;
; input
; - `hl` : destination
; - `bc` : size
;
; destroys `af`, `bc`, `hl`
vmemcplh:
	WAIT_BLANK

	ld a, [hl]
	cpl
	ld [hli], a
	dec c
	jr nz, vmemcplh
	ret
; vmemcplh


; vmemcpl
;
; input
; - `hl` : destination
; - `bc` : size
;
; destroys `af`, `bc`, `hl`
vmemcpl:
	inc b
	inc c
	jr .skip

	.loop
		WAIT_BLANK

		ld a, [hl]
		cpl
		ld [hli], a
		.skip
		dec c
	jr nz, .loop
		dec b
	jr nz, .loop
	ret
; vmemcpl